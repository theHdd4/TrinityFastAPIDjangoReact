"""
FastAPI router exposing the workflow insight agent.
"""

from __future__ import annotations

import asyncio
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field, validator

from .workflow_insight_agent import get_workflow_insight_agent

router = APIRouter(prefix="/workflow-insight", tags=["Workflow Insight"])


class StepRecordPayload(BaseModel):
    step_number: Optional[int] = Field(None, description="Ordinal position of the step")
    agent: Optional[str] = Field(None, description="Agent or atom ID")
    action: Optional[str] = Field(None, description="Action label if applicable")
    description: Optional[str] = Field(None, description="Planner description for the step")
    insight: Optional[str] = Field(None, description="Previously generated step insight")
    result_preview: Optional[str] = Field(None, description="Condensed representation of raw result")
    output_files: Optional[List[str]] = Field(default=None, description="Files generated by the step")
    raw_result: Optional[Dict[str, Any]] = Field(None, description="Raw execution payload")

    @validator("output_files", pre=True, always=True)
    def _ensure_list(cls, value):  # noqa: D401
        """Ensure output_files is a list for downstream processing."""
        if value is None:
            return []
        if isinstance(value, list):
            return value
        return [value]


class WorkflowInsightRequest(BaseModel):
    user_prompt: str = Field(..., description="Original user intent for the workflow")
    step_records: List[StepRecordPayload] = Field(..., description="Ordered step records")
    session_id: Optional[str] = Field(None, description="Execution session identifier")
    workflow_id: Optional[str] = Field(None, description="Frontend workflow identifier")
    file_context: Optional[Dict[str, Any]] = Field(None, description="Pre-built file context dictionary")
    available_files: Optional[List[str]] = Field(None, description="All files visible before the workflow started")
    generated_files: Optional[List[str]] = Field(None, description="Files created during workflow execution")
    additional_context: Optional[str] = Field(None, description="Any extra notes for the narrator")
    client_name: str = Field("", description="Client name for dynamic MinIO prefix resolution")
    app_name: str = Field("", description="App name for dynamic MinIO prefix resolution")
    project_name: str = Field("", description="Project name for dynamic MinIO prefix resolution")


class WorkflowInsightResponse(BaseModel):
    success: bool = Field(..., description="Whether the LLM produced a narrative insight")
    insight: str = Field(..., description="Narrative paragraph(s)")
    used_steps: Optional[int] = Field(None, description="Number of step records used")
    files_profiled: Optional[int] = Field(None, description="How many files were described")
    error: Optional[str] = Field(None, description="Error message if success is False")


@router.post("/generate", response_model=WorkflowInsightResponse)
async def generate_workflow_insight(request: WorkflowInsightRequest):
    """
    Generate a long-form insight paragraph for the supplied workflow steps.
    """

    if not request.step_records:
        raise HTTPException(status_code=400, detail="step_records cannot be empty")

    agent = get_workflow_insight_agent()
    payload = {
        "user_prompt": request.user_prompt,
        "step_records": [record.dict(exclude_none=True) for record in request.step_records],
        "session_id": request.session_id,
        "workflow_id": request.workflow_id,
        "file_context": request.file_context,
        "available_files": request.available_files or [],
        "generated_files": request.generated_files or [],
        "additional_context": request.additional_context or "",
        "client_name": request.client_name,
        "app_name": request.app_name,
        "project_name": request.project_name,
    }

    loop = asyncio.get_running_loop()
    result = await loop.run_in_executor(None, lambda: agent.generate_workflow_insight(payload))

    if not result.get("success"):
        return WorkflowInsightResponse(
            success=False,
            insight=result.get("insight", ""),
            error=result.get("error"),
            used_steps=result.get("used_steps"),
            files_profiled=result.get("files_profiled"),
        )

    return WorkflowInsightResponse(
        success=True,
        insight=result.get("insight", ""),
        used_steps=result.get("used_steps"),
        files_profiled=result.get("files_profiled"),
    )

