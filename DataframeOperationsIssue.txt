Issue: Reopening a project after performing DataFrame operations fails with a browser error `QuotaExceededError: Failed to execute 'setItem' on 'Storage': Setting the value of 'current-project' exceeded the quota.`

Reason: Large results from DataFrame operations were being cached in `localStorage`. When switching projects, these oversized entries remained and `current-project` could not be written, causing the project to fail loading.

Potential Prognosis: Without trimming or clearing these cached items, repeated DataFrame interactions can fill the browser's storage. Users would be unable to reopen projects until manually clearing site data, leading to potential data loss or confusion.

Implemented Changes:
- Added a safe storage helper (`saveCurrentProject`) that strips in-memory DataFrame data and catches quota errors. When storage is full, it now purges heavy cache keys before retrying, preventing the `QuotaExceededError` and allowing projects to reopen reliably.
- Laboratory saves now strip large DataFrame results before sending them to the backend, and the server sanitizes DataFrame-operation atoms before writing to MongoDB so only configuration (not the data itself) is persisted and retrieved.

Issue: Saving a DataFrame from the DataFrame Operations atom produced the original, unmodified dataset.

Reason: The save routine reused the original file name and cached rows, so MinIO persisted the untouched source file instead of the edited table.

Potential Prognosis: Users could believe their changes were stored, but reopening the file would reveal stale data, causing confusion or accidental loss of work.

Implemented Changes:
- The save handler now captures the latest table state and names files using the pattern `DF_OPS_{SerialNumber}_{FileName}` inside the `dataframe operations` folder so each save writes a distinct, updated Arrow file.

Issue: Uploading a file in the DataFrame Operations atom caused a phantom scroll area with extra whitespace below the table.

Reason: A JavaScript height lock mis-measured the scroll region after uploads. When the browser produced stray blocks the `scrollHeight` ballooned and the explicit height created a large blank area.

Potential Prognosis: Repeated uploads would continue to reserve stale space, confusing users with persistent blank areas and awkward scrolling.

Implemented Changes:
- Dropped the JS height lock and `ResizeObserver`.
- Let flexbox with `min-h-0` and `overflow-auto` make the center column the only scroller so its height follows content naturally.
- Corrected invalid table markup by moving the row-resize handle into the final `<td>` so the absolutely positioned handle stays scoped within the row and no longer creates stray whitespace.
