Viewing Saved DataFrames
=========================

The platform allows you to open any dataframe saved through the **Data Upload & Validate** atom in a dedicated viewer tab. The viewer is implemented in React and styled using Tailwind CSS with shadcn/ui components.

Libraries Used
--------------
- **React 18** with TypeScript
- **react-router-dom** to parse the `name` query parameter
- **lucide-react** for icons
- **shadcn/ui** components (`Badge`, `Input`, `Table`, `Pagination`, etc.)
- **Tailwind CSS** for utility classes

Opening a Saved DataFrame
-------------------------
1. In Laboratory Mode, upload your dataset via the **Data Upload & Validate** atom and click **Save DataFrames**. The backend stores an Arrow file in MinIO.
2. Open the auxiliary menu and click the database icon to reveal the **Saved DataFrames** panel.
3. Each saved file is listed with its display name. Clicking a filename triggers `window.open('/dataframe?name=<object>', '_blank')` in `SavedDataFramesPanel.tsx` so the viewer opens in a new browser tab.
4. The new tab renders `DataFrameView.tsx`. During `useEffect`, it fetches the CSV text from `${FEATURE_OVERVIEW_API}/cached_dataframe?object_name=<name>` and parses it into rows:

```
useEffect(() => {
  if (!name) return;
  fetch(`${FEATURE_OVERVIEW_API}/cached_dataframe?object_name=${encodeURIComponent(name)}`)
    .then(res => res.text())
    .then(text => {
      const parsed = parseCSV(text);
      const tableData: DataTableData = {
        headers: parsed.headers,
        rows: parsed.rows,
        fileName: name.split('/').pop() || name,
      };
      setData(tableData);
      setSettings(prev => ({ ...prev, selectedColumns: parsed.headers }));
      setColumnFilters({});
      setCurrentPage(1);
    })
    .catch(() => {
      setData(null);
    });
}, [name]);
```

Replicating the Viewer
----------------------
1. Create a route `/dataframe` that renders the `DataFrameView` component.
2. Read the `name` search parameter and fetch the CSV text from the backend endpoint above.
3. Parse the text into headers and rows (see `parseCSV` in the source). Store the result in state.
4. Render a table with sticky headers. The table supports:
   - Sorting by clicking headers (`handleSort`).
   - Search across all columns.
   - Per-column filter menus with checkboxes.
   - Pagination with a default of 25 rows per page.
5. Use Tailwind classes to style elements (`bg-white`, `border-gray-200`, `rounded-lg`, etc.) so it matches the rest of the app.
6. Icons like `Search`, `Grid3X3`, `Eye`, `Filter` come from `lucide-react` and appear in the toolbar.

Style Guide
-----------
- Keep the outer container `min-h-screen bg-gray-50 flex flex-col` with a white header.
- The table itself sits inside a `bg-white rounded-lg border` element for clarity.
- Use gradients (e.g., `bg-gradient-to-r from-blue-50 to-purple-50`) for the header strip as in the original code.
- Maintain consistent spacing using Tailwind’s `p-4`, `space-x-*` and `space-y-*` utilities.

By following these steps and using the same libraries the Trinity interface uses, you can reproduce the saved dataframe viewer exactly.

Table Logic and Use of TanStack
------------------------------
The viewer does **not** rely on TanStack React Table or any other table library.
Instead, it uses shadcn's lightweight `Table` components which are thin wrappers
around the native `<table>` element styled with Tailwind CSS. All table
behaviour—sorting, searching, per-column filtering and pagination—is coded
manually in `DataFrameView.tsx` using React state.

TanStack React Query **is** included for data fetching elsewhere in the app, but
it plays no part in the table logic here. The shadcn components simply provide
the markup structure, while the logic is built with custom React hooks and
utility functions.
