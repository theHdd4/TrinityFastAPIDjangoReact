"""Mongo persistence helpers for exhibition layout data."""

from __future__ import annotations

import logging
import math
from datetime import datetime
from numbers import Number
from typing import Any, Dict, Iterable, List

from motor.motor_asyncio import AsyncIOMotorCollection

try:  # pragma: no cover - pymongo should be available at runtime
    from pymongo.errors import PyMongoError
except Exception:  # pragma: no cover - executed only when pymongo missing
    PyMongoError = Exception  # type: ignore[assignment]

logger = logging.getLogger(__name__)

def _normalise_cards(cards: Any) -> List[Dict[str, Any]]:
    if not isinstance(cards, list):
        return []

    sanitised: List[Dict[str, Any]] = []
    for card in cards:
        if isinstance(card, dict):
            sanitised.append(dict(card))
    return sanitised


def _coerce_int(value: Any) -> int | None:
    """Safely coerce the supplied ``value`` into an integer."""

    if isinstance(value, bool):
        # ``bool`` is a subclass of ``int`` but we do not want ``True``/``False``
        # to become meaningful z-index values, so treat them as missing.
        return None

    if isinstance(value, Number):
        if isinstance(value, complex):
            return None
        if isinstance(value, float) and not math.isfinite(value):
            return None
        return int(round(float(value)))

    if isinstance(value, str):
        cleaned = value.strip()
        if not cleaned:
            return None
        try:
            parsed = float(cleaned)
        except ValueError:
            return None
        if not math.isfinite(parsed):
            return None
        return int(round(parsed))

    return None


def _normalise_slide_objects(slide_objects: Any) -> Dict[str, Any]:
    if not isinstance(slide_objects, dict):
        return {}

    sanitised: Dict[str, List[Dict[str, Any]]] = {}

    for key, value in slide_objects.items():
        if not isinstance(key, str) or not isinstance(value, Iterable):
            continue

        objects: List[Dict[str, Any]] = []
        for index, entry in enumerate(value):
            if not isinstance(entry, dict):
                continue

            candidate = dict(entry)

            # Support both camelCase and snake_case variants when normalising
            # persisted payloads generated by older clients.
            raw_z_index = candidate.pop("z_index", None)
            if raw_z_index is None and "zIndex" in candidate:
                raw_z_index = candidate.get("zIndex")

            resolved_z_index = _coerce_int(raw_z_index)
            if resolved_z_index is None:
                resolved_z_index = index + 1

            candidate["zIndex"] = resolved_z_index

            objects.append(candidate)

        sanitised[key] = objects

    return sanitised


def _build_document(
    *,
    client_name: str,
    app_name: str,
    project_name: str,
    mode: str,
    cards: Iterable[Dict[str, Any]],
    slide_objects: Dict[str, Any],
    timestamp: datetime,
    autosaveEnabled: bool = True,
) -> Dict[str, Any]:
    return {
        "client_name": client_name,
        "app_name": app_name,
        "project_name": project_name,
        "mode": mode,
        "document_type": "layout_snapshot",
        "cards": list(cards),
        "slide_objects": slide_objects,
        "autosaveEnabled": autosaveEnabled,
        "updated_at": timestamp,
    }


async def save_exhibition_list_configuration(
    *,
    client_name: str,
    app_name: str,
    project_name: str,
    exhibition_config_data: Dict[str, Any],
    collection: AsyncIOMotorCollection,
) -> Dict[str, Any]:
    """Persist the active exhibition slides to MongoDB.

    Parameters
    ----------
    client_name, app_name, project_name:
        Identity values that scope the stored configuration.
    exhibition_config_data:
        Payload containing the ``cards`` collection and optional
        ``slide_objects`` mapping supplied by the frontend.
    collection:
        Authenticated Motor collection reference targeting the
        ``exhibition_list_configuration`` collection.
    """

    client_id = client_name.strip()
    app_id = app_name.strip()
    project_id = project_name.strip()
    mode = exhibition_config_data.get("mode") or "exhibition"

    cards = _normalise_cards(exhibition_config_data.get("cards"))
    slide_objects = _normalise_slide_objects(exhibition_config_data.get("slide_objects"))
    autosaveEnabled = exhibition_config_data.get("autosaveEnabled", True)

    timestamp = datetime.utcnow()

    filter_query = {
        "client_name": client_id,
        "app_name": app_id,
        "project_name": project_id,
        "document_type": "layout_snapshot",
    }

    document = _build_document(
        client_name=client_id,
        app_name=app_id,
        project_name=project_id,
        mode=mode,
        cards=cards,
        slide_objects=slide_objects,
        timestamp=timestamp,
        autosaveEnabled=autosaveEnabled,
    )

    try:
        # Remove any legacy exhibition documents that stored laboratory atoms so the
        # collection only retains the slide metadata snapshot for the active project.
        legacy_filter = {
            "client_name": client_id,
            "app_name": app_id,
            "project_name": project_id,
            "document_type": {"$ne": "layout_snapshot"},
        }
        await collection.delete_many(legacy_filter)

        # Remove stray records that may exist in the legacy ``trinity`` database so
        # the slide configuration lives exclusively inside ``trinity_db``.
        if collection.database.name != "trinity":
            legacy_db_collection = collection.database.client["trinity"][collection.name]
            await legacy_db_collection.delete_many(legacy_filter)

        result = await collection.replace_one(filter_query, document, upsert=True)
        documents_written = 1 if (result.upserted_id or result.modified_count or result.matched_count) else 0

        logger.info(
            "üì¶ Stored exhibition layout snapshot for %s/%s/%s in %s.%s",
            client_id,
            app_id,
            project_id,
            collection.database.name,
            collection.name,
        )

        return {
            "status": "success",
            "updated_at": timestamp,
            "documents_written": documents_written,
            "collection": collection.name,
            "database": collection.database.name,
        }

    except PyMongoError as exc:  # pragma: no cover - depends on runtime infra
        logger.error(
            "‚ùå MongoDB save error for %s.%s: %s", collection.database.name, collection.name, exc
        )
        return {"status": "error", "error": str(exc)}

