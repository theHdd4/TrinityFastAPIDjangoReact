# FastAPI Feature Creation Guide

This guide explains how to create a new FastAPI feature in the Trinity project. Each feature lives under `TrinityBackendFastAPI/app/features` and exposes its routes through `app/api/router.py`.

## 1. Directory Structure

```
TrinityBackendFastAPI/app/
├── api/router.py           # central router
└── features/
    └── <feature_name>/
        ├── endpoint.py     # includes the router
        ├── routes.py       # path operations
        ├── service.py      # business logic (optional)
        └── deps.py         # dependencies (Mongo, Redis)
```

`endpoint.py` typically creates an `APIRouter` and attaches the routes from `routes.py`:

```python
# endpoint.py
from fastapi import APIRouter
from .routes import router as feature_routes

router = APIRouter()
router.include_router(feature_routes, prefix="/my-feature", tags=["My Feature"])
```

Register this router in `app/api/router.py`:

```python
from app.features.my_feature.endpoint import router as my_feature_router
api_router.include_router(my_feature_router)
```

## 2. Saving and Loading from MongoDB

Use `motor` to interact with MongoDB. Dependencies can be stored in `deps.py`:

```python
# deps.py
from motor.motor_asyncio import AsyncIOMotorClient
import os

MONGO_URI = os.getenv("MONGO_URI", "mongodb://mongo:27017/trinity")
client = AsyncIOMotorClient(MONGO_URI)
my_collection = client["my_db"]["my_collection"]
```

In `service.py` you can insert and fetch documents:

```python
# service.py
from datetime import datetime
from .deps import my_collection

async def save_record(data: dict) -> None:
    doc = {**data, "created_at": datetime.utcnow()}
    await my_collection.insert_one(doc)

async def load_record(name: str) -> dict | None:
    return await my_collection.find_one({"name": name})
```

## 3. Saving and Loading from Redis

Reuse the Redis client defined for feature overview or create one in your own `deps.py`:

```python
import redis

REDIS_HOST = os.getenv("REDIS_HOST", "redis")
redis_client = redis.Redis(host=REDIS_HOST, port=6379, decode_responses=False)
```

Store objects with an expiry time and retrieve them later:

```python
import json

async def cache_data(key: str, data: dict, ttl: int = 3600) -> None:
    redis_client.setex(key, ttl, json.dumps(data))

async def load_cached(key: str) -> dict | None:
    val = redis_client.get(key)
    return json.loads(val) if val else None
```

## 4. Example Feature: Greeting Service

1. Create `TrinityBackendFastAPI/app/features/greet/` with `endpoint.py`, `routes.py`, and `service.py`.
2. `endpoint.py` exposes the router as shown above.
3. `routes.py` defines two endpoints:

```python
# routes.py
from fastapi import APIRouter
from .service import save_record, load_record, cache_data, load_cached

router = APIRouter()

@router.post("/greet")
async def create_greeting(name: str):
    await save_record({"name": name})
    await cache_data(f"greet:{name}", {"greeting": f"Hello {name}!"})
    return {"status": "saved"}

@router.get("/greet/{name}")
async def get_greeting(name: str):
    cached = await load_cached(f"greet:{name}")
    if cached:
        return cached
    record = await load_record(name)
    return {"greeting": f"Hello {record['name']}"} if record else {"detail": "Not found"}
```

4. Add `from app.features.greet.endpoint import router as greet_router` to `app/api/router.py` and include it with `api_router.include_router(greet_router)`.
5. Rebuild the FastAPI container. Requests to `/api/greet/greet` will now store and return greetings using both MongoDB and Redis.

This workflow ensures new features follow the same layout and take advantage of the existing MongoDB and Redis helpers.
